package com.lightform.mercury

import cats.Applicative
import cats.implicits._
import com.lightform.mercury.json.JsonSupport
import com.typesafe.scalalogging.LazyLogging

import scala.collection.immutable.IndexedSeq

trait ServerTransportHint[A] {

  /**
    * @param request the incoming request from the client, none if there was an issue parsing the request
    * @param response the response generated by the server or business logic
    * @return
    */
  def hint(request: Option[Request[Any]], response: Response[Any, Any]): A
}

object ServerTransportHint {
  implicit object PureServerTransportHint extends ServerTransportHint[Unit] {
    def hint(request: Option[Request[Any]], response: Response[Any, Any]) = ()
  }
}

abstract class Server[F[+_]: MonadException: Applicative, Json: JsonSupport, Hint: ServerTransportHint, CCtx, RCtx]
    extends LazyLogging {
  private val jsonSupport = implicitly[JsonSupport[Json]]
  private val transportHint = implicitly[ServerTransportHint[Hint]]

  import jsonSupport._

  protected def handlers: Seq[Handler[F, Json, Hint, CCtx, RCtx]]

  protected lazy val _handlers =
    handlers.map(h => h.method.method -> h).toMap

  protected def handle(
      json: Json,
      connectionCtx: CCtx,
      requestCtx: RCtx
  ): F[Option[(Json, Hint)]] = {

    val errorOrRequest = jsonSupport
      .requestReader[Json]
      .read(json)
      .toEither
      .leftMap(
        e =>
          ErrorResponse(
            UnexpectedError.fromData(
              -32600,
              "Invalid Request",
              e.getMessage
            ),
            idLens(json)
          )
      )

    def errorOrHandler =
      methodLens(json)
        .flatMap(method => _handlers.get(method))
        .toRight(
          ErrorResponse(
            UnexpectedError.fromData(
              -32601,
              "Method not found",
              "The method does not exist / is not available."
            ),
            idLens(json)
          )
        )

    val errorOrResult = for {
      request <- errorOrRequest
      handler <- errorOrHandler
      result <- Right(handler.handle(request, connectionCtx, requestCtx))
    } yield result
      .recover {
        case e =>
          logger.error(
            s"Exception in handler for ${handler.method.method} " +
              s"for${request.id.map(_ => "").getOrElse(" notification")} " +
              s"request ${request.id.map(_.idToString).getOrElse("")}",
            e
          )

          request.id.map(
            id =>
              ErrorResponse(
                UnexpectedError(-32000, "Internal error", None),
                Some(id)
              )
          )
      }

    mergeErrorOrResult(errorOrRequest.toOption, errorOrResult)
  }

  protected def handle(
      jsonString: IndexedSeq[Byte],
      connectionCtx: CCtx,
      requestCtx: RCtx
  ): F[Option[(Json, Hint)]] = {
    val errorOrJson =
      parse(jsonString).toEither
        .leftMap(
          e =>
            ErrorResponse(
              UnexpectedError.fromData(
                -32700,
                "Parse error",
                e.getMessage
              ),
              None
            )
        )

    serializeAndHintError(
      errorOrJson
        .map(json => handle(json, connectionCtx, requestCtx))
    ).merge
  }

  private def serializeAndHintError[A](
      errorOr: Either[ErrorResponse[String], A]
  ) =
    errorOr
      .leftMap(
        response =>
          (
            responseWriter[String, Nothing].writeSome(response),
            transportHint.hint(None, response)
          )
      )
      .leftMap(Some(_))
      .leftMap(_.pure[F])

  private def mergeErrorOrResult(
      maybeRequest: Option[Request[Any]],
      errorOrResult: Either[ErrorResponse[String], F[
        Option[Response[Option[Json], Json]]
      ]]
  ) =
    serializeAndHintError(errorOrResult)
      .map(
        _.map(
          _.map(
            response =>
              (
                responseWriter[Option[Json], Json].writeSome(response),
                transportHint.hint(maybeRequest, response)
              )
          )
        )
      )
      .merge

  def start: F[Unit]
}
